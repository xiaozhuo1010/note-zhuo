# 经典排序

以下的例子都为升序



## 冒泡排序

- 复杂度：
  - 最佳情况：可以们在最后一次交换的地方进行记录，在这元素之前 / 之后的所有元素有序，因此最好的情况就是数组有序 O(n)。
  - 最差情况：数组反向有序排列，O(n ^ 2)
  - 平均复杂度：O(n ^ 2)
- 稳定性：
  - 比较是相邻的两个元素比较，交换也发生在这两个元素之间，因此是稳定排序



## 选择排序

复杂度

- 没有最佳和最差情况。
- 平均情况：O(n2)

稳定性：

- 因为选择排序会在无序区间选择最大/最小值并插入到有序区间，这种交换就无法保证稳定性
- 如 5 8 5 2 9 就会导致 第一个 5 和 2 交换，丧失了稳定性



## 插入排序

复杂度：

- 最佳情况：输入数组有序排列。T(n) = O(n)
- 最坏情况：输入数组反向有序排列。T(n) = O(n2)
- 平均情况：T(n) = O(n2)

稳定性：

- 无序区间是一个个从前往后遍历的，因此是稳定排序



## 希尔排序

插入排序的优化。

- 利用了==插入排序对于越接近有序的数组效果越好的特点==，逐步增加分组的大小，由于每一次都是基于上一次排序后的结果，所以每一次都可以看做是一个比较有序的序列，所以能够最大化插入排序的优点。

复杂度：

- 时间复杂度根据选择的增量序列不同而不同，下面以gap每次减少一半为例
- 最佳情况：数组有序，T(n) = O(nlog2 n)
- 最坏情况：数组反向有序，相当于插入排序，T(n) = O(n^2) 
- 平均情况：T(n) =O(nlog2 n)

稳定性：

- 单次插入排序是稳定的，因为都是在相邻两元素进行操作，但是希尔排序由于引入了 gap 并多次插入排序，因此丧失了稳定性。

~~~js
function hillSort(array) {
  let length = array.length;
  // 每次间隙的大小减半
  for (let gap = length >> 1; gap >= 1; gap = gap >> 1) {
    for (let i = gap; i < length; i++) {
      let key = array[i];
      let j = i - gap;
	// 对每个分组使用插入排序
      while (j>= 0 && array[j] > key) {
        array[j + gap] = array[j];
        j -= gap;
      }
      array[j + gap] = key;
    }
  }

  return array;
}
~~~



## 快速排序

处理大数据最快的排序算法，是冒泡排序的优化

- 利用了冒泡排序对越接近有序的数组效果越好的特点。

- 快速排序相当于将数组看成三个元素：两个子数组和一个枢纽元素，然后可以将小于枢纽元素的元素冒泡到枢纽左边，大于的反之，因此快排被看成是是优化版的冒泡排序。

复杂度：

- 复杂度取决于递归的深度，最好情况为 nlogn ，最差为 n2
- 最坏情况是数组正反向有序，相当于冒泡排序（冒泡枢纽元素）
- 最好情况是每次划分都是1 ：1的划分。
- 空间复杂度：递归时压入栈的深度为 O(logn) - O(n)

稳定性：

- 不稳定发生在中枢元素和 a[mid] 交换的时刻；

~~~js
function quickSort(array, start, end) {
  if (array.length <= 1 || start > end) return;

  let index = partition(array, start, end);
  quickSort(array, start, index - 1); 
  quickSort(array, index + 1, end); 
  return array;
}

// 挖坑法，先挖枢纽，然后挖右坑填左坑，左坑填右坑
function partition(array, start, end) {
  let pivot = array[start]; 
  while (start < end) {
	// 从 end 往前找第一个小的
    while (array[end] >= pivot && start < end) {
      end--;
    }
    array[start] = array[end];
	
    // 从 start 往后找第一个大的
    while (array[start] < pivot && start < end) {
      start++;
    }
    array[end] = array[start];
  }

  // 遍历完最后 start = end 且为分界点，就可以将枢纽换回来了。
  array[start] = pivot;
  return start;
}
~~~



## 归并排序

归并排序采用了最经典的分治算法：分解、解决、合并

- 递归的将数组两两分开直到只包含一个元素，排序后两两合并。
- 相当于将一个数组分解成一个二叉树

复杂度分析：

- 由于二叉树的深度始终为 logn，遍历二叉树时间为 n ，所以==归并排序的时间复杂度不管在什么情况下都为O(nlogn)。==
- 空间复杂度为 O(n)

稳定性：

- 合并两个有序数组时是一个个 从前往后比较，因此稳定。

~~~js
var sortArray = function (array) {
    const tempArr = Array.from(array).fill(undefined);
    return mergeSort(array, 0, array.length - 1, tempArr);
};
function mergeSort(nums, l, r, tempArr) {
    if (l >= r) return nums;
    const mid = (l + r) >> 1;
    mergeSort(nums, l, mid, tempArr);
    mergeSort(nums, mid + 1, r, tempArr);
    return merge(nums, l, mid, r, tempArr);
}

// 合并两个有序数组
function merge(nums, l, mid, r, tempArr) {
    let c = l, i = l, j = mid + 1;
    while (i <= mid && j <= r) {
        tempArr[c++] = (nums[i] < nums[j] ? nums[i++] : nums[j++]);
    }
    while (i <= mid) {
        tempArr[c++] = nums[i++];
    }
    while (j <= r) {
        tempArr[c++] = nums[j++];
    }
    for(let m = l;m<=r;m++){
            nums[m]=tempArr[m];
    }
    return nums
}
~~~



## 堆排序

它可以看成是选择排序的优化（优化了找到最大 / 最小值的方式）。

完全二叉树：树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树

思路：

- 将数组看做一个==堆的层序遍历==的结果。
- 堆的性质：
  - **大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]**  

- **小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]**  
- 一般升序采用大顶堆，降序采用小顶堆
- 将待排序序列构造成一个大 / 小顶堆，再==将堆顶的根节点与末尾元素进行交换==并重新建堆。如此反复执行

复杂度分析：

建立堆的时间复杂度为 O(n)，但调整堆的时间复杂度为 O(logn)，调整了 n 次，因此堆排序的时间复杂度在不管什么情况下都是 O(nlogn)。

~~~js
var sortArray = function (array) {
    // 找到第一个非叶子节点
    const lstParent = (array.length >> 1) - 1;
    // 从第一个非叶子节点向上建立堆
    for(let i = lstParent; i >= 0; i--){
        adjustTree(array, i, array.length - 1);
	}
    // 循环将堆顶元素和最后元素交换，并重新调整
    for(let i = array.length - 1; i > 0; i--){
        [array[i], array[0]] = [array[0], array[i]];
        adjustTree(array, 0, i - 1);
    }
    return array
};
// 调整函数只关注根节点大于他左右子树的任意节点即可
function adjustTree (array, l, r) {
    // iMax 记录最大的元素，left/right记录其左右节点
    let iMax, iLeft, iRight;
    while(true){
        iMax = l;
        iLeft = 2 * l + 1;
        iRight = 2 * l + 2;
         // 比较的先后顺序没有差别，因为是最后才进行交换
        if(iLeft <= r && array[iMax] < array[iLeft]){
            iMax = iLeft;
        }
        if(iRight <= r && array[iMax] < array[iRight]){
            iMax = iRight;
        }
        // 如果出现了子节点比父节点大的情况（索引被交换了），就交换他们的值
        if(iMax !== l){
            [array[l], array[iMax]] = [array[iMax], array[l]];
            // 然后从被交换的子元素继续向下调整
            l = iMax;
        }else  break
    }
}
~~~



## 分析

什么是排序的稳定性：对于相同大小的元素，如果排序之后能保证他们的相对顺序没有发生变化，就说明是稳定的。

排序方法	平均情况	       最好情况	最坏情况	辅助空间	稳定性
冒泡排序	O(n^2)	             O(n)	O(n^2)	O(1)	稳定
选择排序	O(n^2)	            O(n^2)	O(n^2)	O(1)	稳定
插入排序	O(n^2)	            O(n)	O(n^2)	O(1)	稳定
希尔排序	O(nlogn~n^2)   O(n^1.3)	O(n^2)	O(1)	不稳定
堆排序    	O(nlogn)	        O(nlogn)	O(nlogn)	O(1)	不稳定
归并排序	O(nlogn)	        O(nlogn)	O(nlogn)	O(n)	稳定
快速排序	O(nlogn)	        O(nlogn)	O(n^2)	O(logn)~O(n)	不稳定

归并排序的优势是稳定，且没有最坏情况，但是需要辅助空间。

快排和堆排只能说实验证明快排更快。



## topK 问题

可以通过将数组排序来取，优化方向就是局部排序。

首先最先想到的肯定是冒泡排序，冒泡 k 次即可。

- 时间复杂度：O(n*k)

再者，找出最大的 k 个元素如果没有顺序要求，可以考虑使用堆来找到 topK ：

- 将数组前 k 个元素构建成==小顶堆==，然后对剩余元素进行扫描，如果有元素大于堆顶，则交换并调整堆，就能保证这个堆里是最大的 k 个元素。
- 时间复杂度：O(n*log(k)) n 个元素（调整堆的复杂度是堆的高度）

此外，还有时间复杂度为O(n)的方法，基于快排的减治策略

- 随机选择：核心思想就是分治，其中减治法比较特殊，分治是分解的子问题都解决，减治是解决一个特定的子问题，如二分查找。

- 快排应用的是分治思想，但是应用在 topK 中，就是减治思想。找到第 k 大的数，做一次 partition ，就可以找到最大的 k 个数。因此问题就来到了最大的第 k 个数

- ~~~js
  const i = partition(array, 0, length - 1);
  // length - i - 1 > k，第 k 大元素在右边，递归array[i, length - 1]
  // 反之则递归左边
  ~~~

基于快排的方法优点在于时间复杂度略小，但是会修改原数组，且空间复杂度大。而基于堆排序的方法优点在于空间复杂度是常数值，且不修改原数组，适用于数据量较大的情况。



## 数据流中的中位数

如果使用数组来保存数据，我们可以使用参考快排的 Partition 函数来获得中位数（topk问题）；还可以只是在插入的时候将新元素插入类似于插入排序一样插入到合适的位置，中位数直接按照索引求得就行了。 

如果使用一个排序的链表，则我们需要 O(n) 的时间找到合适的位置插入，但是可以通过定义两个指针（因为偶数长度数据的中位数需要取平均值），来在 O(1) 的时间获得中位数。

使用二叉搜索树可以将插入新数据的时间减低到 O(logn)  ，但是如果二叉搜索树非常不平衡，那么它的复杂度就会无限趋近于排序链表。

此外，我们注意到整个数据容器可以被分成两部分，左边部分的所有数据比右边部分的所有数据都小，这时让指针 p1 指向左边数据最大的一个元素，p2 指向右边数据最小的一个元素。那么只需要保证左边的数据都小于右边的数据，即使左右数据都没有排序，也可以直接得到中位数。即使用最大堆、最小堆。

我们可以用一个最大堆实现左边的容器，最小堆实现右边的容器。那么插入一个数据的时间复杂度就是 O(logn)。

- 当数据的总数是偶数时，将新数据插入右边的最小堆，否则就插入左边的最大堆。
- 此外需要保证最大堆的所有数据都要小于最小堆的所有数据，所以如果我们要将一个数据插入最小堆，就要先将它插入最大堆，然后将最大堆的堆顶插入最小堆，反之同理。



## 数组中的逆序对

第一反应就是遍历数组，每一个元素分别向后面遍历比较，时间复杂度较高。

逆序对的意思是与顺序相反了，那么自然会想到排序，如果是冒泡排序的话，交换一次就代表了一个逆序对的交换，那么也可以使用冒泡排序，统计交换次数来实现。

既然都想到冒泡排序了，那可以考虑排序的优化，而冒泡排序的优化就是快速排序，我们也可以统计交换的次数，来得到逆序对的个数；

书中提到的是利用归并排序，也可以。归并排序的好处在于从后往前遍历时，如果遇到一个逆序对，则前面的元素也都是逆序对了（因为是有序数组），减少了次数。



# 查找

## 前置知识

###  二分查找

二分查找的条件是数组必须是有序的

1. right 指针 =  arr.length - 1 还是 arr.length ，决定了区间是开区间还是闭区间。
2. while 循环条件是 `left < right`  还是 `left <= right `需要配合前面的区间
   - 因为 left === right 时，这个元素还需要再比较一次，所以有下面的配合：
     - `left <= right `配合`左闭右闭`区间
     - `left < right `配合前面的左闭右开区间。

### 回溯算法

- 如果题目类似在一个二维数组中搜索某条路径，可以使用回溯法。
- 在回溯算法向前的每一步都会去设置某个状态，而当向前走走不通的时候回退并撤销本次设置的状态。
- 回溯是递归的副产品，只要有`递归就会有回溯`。
- 回溯法搜索过程中用**剪枝函数**避免无效搜索，其实也是一种减治思想



## 字符串的排列 

输入一个字符串，打印出该字符串中所有字符的排列。

这种题目，是一个能分解的问题，可以用递归的思路去解决。并且使用回溯法及剪枝来寻找不同排列并排除不正确的选项。

剪枝：如果输入的字符串中有重复字符，我们也需要保证排除重复的结果，即保证	每个字符都只在某位固定一次，如果出现了同一个字符在某位固定多次就直接返回函数，即剪枝。

递归：

- 结束条件：字符串组合到了合适的长度就返回

- 每一次的操作：

  - 我们将一个组合的字符串分为前面固定了的部分、一个待交换的字符和后面未固定的部分，每次操作都交换这个字符和后面的未固定的字符。

  - 递归完之后需要==恢复状态==，这是回溯法的特质，才能保证两个递归路线不互相影响。

  - ~~~js
    原字符串：abc
    第一层 ： a 和自己交换 得到abc 
    	进入第二层 b和自己交换 得到abc 
        	进入最后一层 结束 得到排列 abc
    	返回第二层 ： b和c交换 
        	进入第三层 结束 得到排列acb
        返回第二层 ： 没有可以交换的，返回第一层
    第一层 ： a 和 b 交换，得到bac
    	进入第二层 a 和自己交换，得bac
        	第三层 得 bac
        第二层 a 和 c 交换
        	第三次 得 bca
    。。。以此类推
    ~~~

要点：

1. 为什么称之为回溯法：因为在递归调用完之后我们需要重置状态实现回溯的效果。
2. 剪枝的定义是在没得出结果的时候就已经能判定下面的操作都是错误的，就将这个’枝‘剪掉了。
3. 除了回溯之外，本题还有一个难点就是每一步递归操作了什么。
   - 我们可以将前面的固定了的字符组合忽略，也就是上层。
   - 然后在这一层中，我们将这个未固定区间第一个字符不断与后面的所有字符交换并递归下去（相当于固定了这个字符）
   - 不要忘了在递归调用之后交换回来，恢复状态。

为什么不使用动态规划？

从动态规划的角度分析：

- 数组：保存在当前位所有字符的可能排列
- 转移方程：f（n） = f （n - 1） +  某个字符，且要跟 f（n - 1）中字符不能重复
- 初始条件： f（1） = a,b,c ...

可以看到，动态规划的优势在于解决重复计算问题，而转移方程是线性的依赖，没有分支，与单纯递归相比计算量一样，且多了辅助空间，反而效率低下。此外，由于不是统计排列数目而是统计排列可能，因此辅助空间的存储方式也会比较复杂。

~~~js
var permutation = function (s) {
    let ans = [],
        sArr = s.split('');
    const dfs = (x) => {
        // 组合的字符串长度符合则推入 res 数组
        if (x === sArr.length - 1) return ans.push(sArr.join(''));
        for (let i = x; i < sArr.length; i++) {
            [sArr[x], sArr[i]] = [sArr[i], sArr[x]];
            dfs(x + 1);
            // 恢复状态
            [sArr[x], sArr[i]] = [sArr[i], sArr[x]];
        }
    }

    dfs(0)
    // 在这一步去重，相当于没有剪枝
    return [...new Set(ans)]
};
~~~

拓展：如果求的是字符的所有组合，如 a ， b， c， ab， ac， bc ，abc 。。。且 ab 和 ba 是同一个组合，该怎么求呢？

和上题思路类似，我们将未固定区间分成第一个字符和其余字符，只不过每次递归不进行交换了（因为和顺序无关）。

- 我们将给出的字符串变为数组，表示可组合的字符。
- 每一次递归操作时，第一个字符可以选择被放入结果或者不放入（因为可以不使用它）
- 也就相当于将问题 n 个字符中取长度为 m 的组合分解成 n - 1 个字符取长度 m - 1个字符和 n - 1个字符取 m 个字符的子问题。
- 比如 abc 这个字符，我们第一个 a 可以选择取用也可以选择不取用，同理 b ，c 也是可以选择取用或者不取用。
- 这种方法的有优点在于我们不必考虑组合的长度了，因为我们都是直接遍历到底，取用与否，遍历的长度都是固定的。

~~~js
// 组合树：以 abc 为例
					begin
              x			    a
         b        x    	 b       x
       c    x   c   x  c   x   c    x
由此看来，这种方法的优点就显现出来了，我们不用考虑组合后的字符长度，我们只需要遍历完之后将字符存下来就行了。
~~~

那么还是这个问题，为什么不使用动态规划呢？

我认为还是一个存储数组的问题，它不是探究有多少种组合方式，那么存储的效率就会非常低下。虽然这个问题产生了重复计算，只能说各有取舍吧。

动态规划的思路：

- 数组存储的是输入字符遍历到对应索引时的所有可能的字符组合
- 转移方程：f（n） = [ for f（n - 1） +  str [n]  ,  for  f（n - 1）]
  - 可以看到存储的东西非常多
- 初始条件：f(1)



# 双指针

双重循环就是一种朴素的双指针 ，只不过是一个个遍历实现移动。

而如果在==有某种规律的数组==中，就存在一种方法，使得两个指针之间存在某种对应关系（依据数组规律），所以只需要一重循环。

一般的数组双指针题目，都是有序数组 + 对撞指针实现的。 

在链表或树中一般使用快慢指针。

滑动窗口：双指针方法的结果只与指针指向的`两端点`相关；滑动窗口方法的结果与两端点表示的`区间`相关。==注意滑动窗口的两指针只允许右移，以便将时间复杂度控制在 O(N) 。==

 

# 字符串

字符串在 js 中一般会出：正则、递归/动态规划。

## 正则表达式匹配

动态规划：力扣解法（边界处理，数组意义，转移方程）

递归：剑指解法



# 热门题

## 链表反转

1. 迭代法

~~~js
let pre = null;
let cur = head;
while(cur){
    const next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
}
// pre 指向反转后的头节点，cur 指向其 next 节点（null）
return pre;
~~~

2. 递归法：当越过尾节点后终止递归，在回溯时修改各节点的 `next` 引用指向。

~~~js
const fn = function (cur, pre) {
    // 这里的 pre 指的是链表反转后cur节点的前一个节点。
    // 递归思路是认为 pre 节点及其之后的节点都指向正确。
    if (pre === null) {
           resHead = cur;
           return cur;
    }
    const preRes = fn(pre, pre.next);
    preRes.next = cur;
    return cur;
}
let resHead = null;
fn(null, head);
return resHead;
~~~

3. 头插法：定义两个指针：一个守卫指针（不动，表示要反转的链表节点的第一个节点的上一个节点），一个移动的指针进行遍历头插。

~~~js
	// 虚拟头节点
    const dummyHead = new ListNode(-1，head);
    const g = dummyHead;
    let p = head;
    // 头插法插入节点，注意条件是 p.next 因为 p 在遍历过程中始终指向一个节点。
    while(p.next){
        // 移除 p 指针的后一个节点，并将其接在 g 指针的后面
        const removed = p.next;
        p.next = p.next.next;
        removed.next = g.next;
        g.next = removed;
    }
    return dummyHead.next;
~~~



## 链表反转 II 

~~~js
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
// 反转指定区间的链表节点
~~~

~~~js
var reverseBetween = function (head, left, right) {

    // 定义一个虚拟的头和尾节点，便于操作
    const dummyHead = new ListNode(-1, head);
    let pre = dummyHead;
    let cur = dummyHead.next;
    // 循环遍历到区间起始点
    for (let i = 1; i < left; i++) {
        pre = pre.next;
        cur = cur.next;
    }
    // 在区间中进行迭代法实现反转链表；
    let leftPreNode = pre;
    let leftNode = cur;
    for (let i = left; i <= right; i++) {
        const next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    leftNode.next = cur;
    leftPreNode.next = pre;
    return dummyHead.next;
};
~~~





# 树

二叉树相比于链表涉及到更多指针操作，因此我们需要非常小心的考虑空指针的问题。



## 对称的二叉树

判断一个二叉树是否对称。

1. 我自己的第一反应是通过一个二叉树的层序遍历，在每一层进行判断。

2. 书中给出的答案是通过一个对称的前序遍历（也就是先遍历右节点再遍历左节点），并将其与普通的前序遍历的结果进行比较，如果相等则是对称的。

3. 递归思路跟上面的遍历差不多，只不过在过程中一个个比较。



## 序列化二叉树

要求提供两个函数，使得二叉树能被序列化和反序列化。

这题可以让我们联想到重建二叉树那题。但是那题的条件是二叉树没有重复的元素且需要提供前序和中序遍历的结果来进行推断。

答案是把null节点也遍历，输出为一个如 '\$' 的占位符。在建树的时候根据一个节点是否左右节点都是 null 来判断是否是 叶子节点，或者数组中下一个元素是在左子树还是右子树。



# 动态规划

- 动态规划通过从下到上迭代，并通过数组记录状态，解决递归产生的重复计算问题，本质上是空间换时间
- 动态规划解决的问题特征：
  1. 可以分解成子问题，并且一个问题的结果和他子问题的结果有关。（递归）
  2. 使用递归解法产生了大量重复计算
- 动态规划的要素：
  - dp 数组
    - dp数组存储的一般是问题结果，即f（n）
    - 而决定一个问题结果的因素不只为索引，还可能是别的依赖，因此需要出现多维数组，以供下一项qu'yo。
  - 初始化条件
  - 转移方程
- 贪心算法：与动态规划相比，我们在每一步都做出一个贪婪的选择（特殊的选择），来得出最优解。



## 正则表达式匹配

对题目进行分析，字符串都是一个个对比的，难点主要在于\*，遇到星号需要分类讨论。

- 为什么迭代不行：因为分类讨论完并不能直接得出结果，也是需要继续向后对比字符。
- 基于递归，那么我们就要思考怎么分解问题，可以将一个个正则的字符看成一个个模块，也就是一个个子问题。
- 由于递归之后也是需要继续向后对比字符，产生了重复计算，因此我们可以考虑动态规划

递归：

~~~js
var isMatch = function (s, p) {
    let i = 0, j = 0;
    return matchCore(s, p, i, j);
};
function matchCore(s, p, i, j) {
    if (i >= s.length && j >= p.length) return true;
    //  没有 i >= s.length && j < p.length 就返回 false 的情况，是因为正则的 *存在匹配0个字符的情况。
    if (i < s.length && j >= p.length) return false;
    if (p[j + 1] === '*'){
        // *号前的字符匹配
        if(p[j] === s[i] || (p[j] === '.' && i <= s.length)){
            //  *匹配1个字符并结束* || *向下匹配 || 忽略*
            return matchCore(s, p, i+1, j+2) || matchCore(s, p, i+1, j) || matchCore(s, p, i, j+2);
        }else{
            // 不匹配，直接忽略*
            return matchCore(s, p, i, j + 2)
        }
    }
    if(s[i] === p[j] || (p[j] === '.' && i < s.length)) return matchCore(s, p, i+1, j+1);
    return false;
}
~~~

动态规划：从上到下分析

- 从后往前看正则，遇到字符，分类讨论，确定转移方程
  - 正常字符，则先对比对应字符是否正确，并各自向前一个字符转移
  - `.`，则两者直接向前转移。
  - `*`，则我们将他的前一个字符一起看成一个子问题。它前面的子字符可以重复任意次。
- 确定数组：`f[i][j] `代表 s 的前 i 个和 p 的前 j 个能否匹配
- 初始条件：
  - 空串和空正则匹配，00 = true；
  - 空串和非空正则，要向下计算；
  - 非空串和空正则置 false；

```js
class Solution {
    public boolean isMatch(String A, String B) {
        int n = A.length();
        int m = B.length();
        // 声明长度为n+1的数组就可以将长度为0的数组考虑在内了
        boolean[][] f = new boolean[n + 1][m + 1];

        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                // 空正则的初始条件
                if (j == 0) {
                    f[i][j] = i == 0;
                } else {
                    //非空正则分为两种情况 * 和 非*
                    if (B.charAt(j - 1) != '*') {
                        if (i > 0 && (A.charAt(i - 1) == B.charAt(j - 1) || B.charAt(j - 1) == '.')) {
                            f[i][j] = f[i - 1][j - 1];
                        }
                    } else {
                        //碰到 * 了，分为看和不看两种情况
                        //不看
                        if (j >= 2) {
                            f[i][j] |= f[i][j - 2];
                        }
                        //看
                        if (i >= 1 && j >= 2 && (A.charAt(i - 1) == B.charAt(j - 2) || B.charAt(j - 2) == '.')) {
                            f[i][j] |= f[i - 1][j];
                        }
                    }
                }
            }
        }
        return f[n][m];
    }
}
```

`|=` ：因为存在上一个 if 已经将该 `f [i][j]`置为 true 了，那么下面的 if 只需要保持 true 就行了。



## 掷骰子

将问题分解： n 个骰子等于 n - 1 个骰子 + 1；

由于每个骰子都是一样的六个点位，每个点位 1/ 6 的概率，因此会产生重复计算，需要使用动态规划

思路： 

- dp 数组： 二维数组，dp\[i][j] 表示前 i 个骰子的点数和为 j 的概率，而由于只是线性的依赖，因此对于 i 而言只需要 i 和 i -1 两个一维数组就行了。
- 递推公式： i 代表多出来的筛子的可能点数（1到6），x 表示点数和
  - f(n, x)=∑ f(n−1,x−i) / 6
- 边界情况： 第一颗骰子

由此题目我们看出来，虽然他是线性依赖，但是从上到下递归也会产生重复计算，因此从下往上可以很好的避免重复计算。

因此动态规划不只是像我之前想的代表一个树形结构（如斐波那契额数列一样）而只是代表了一种从下向上迭代来代替递归的思维。



# 位运算

位运算主要掌握与、或、异或、左移、右移就行。

- 异或： \^   ，两位不相等就取 1， 相等取 0。

- 左移： 最左边的 n 位会被丢弃，右边补符号位的值；
  - 左移可以用来如计算整除 2 的倍数，效率很高。

- 右移： 最右边的 n 位会被丢弃，左边补符号位的值；

数字存储的形式：

- 原码：符号位正数为 0，负数为 1。后面表示其绝对值
- 反码： 符号位正数为 0，负数为 1。后面的值如果是负数则是绝对值二进制取反
- 补码： 如果是负数则在反码的基础上 +1

为何出现了反码和补码？

因为人们希望能不判断符号位，而直接让符号位参与运算，直接得出正确的结果。

~~~js
使用原码直接计算：不能得到正确结果
1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2

使用反码：真值部分正确，但是出现了 -0，因此导致了结果都会小 1
1 - 1 = 1 + (-1) = [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

使用补码： 解决了反码的 -0 问题。
~~~



## 二进制 1 的个数

首先我们的思路一般是：判断一个数最右边一位是否是1，然后将其右移再判断，不断循环。

但是这种解法，对于负数就不行了，因为负数右移会补1，数字就不会像想象中的一样整除 2 了。

为了避免这种情况，我们可以将数字 1 与输入数进行判断，然后左移该数字，判断输入值高一位。

此外，还可以只用更少次数的循环就可以得到结果的方法：

我们发现，一个整数减去 1 ，都会把最右边的 1 变为 0，然后将该 1 的右边所有 0 变为 1，而左边的所有位都保持不变。如`01100 - 00001 = 01011`

然后我们将一个数二进制减去 1 的结果跟自身做与运算，就相当于把该整数二进制最右边的 1 换为了 0 ，其余不变。如`01100 - 00001 = 01011； 01011 & 01100 = 01000`。以此为原理进行循环，就能只遍历 1 了。



## 数组中只出现一次的两个数字

感觉上比较类似之前的找出数组中重复的数字，但是条件并没有数字范围都是 0~n-1 ，所以不允许使用辅助空间，也无法按照索引进行记录。

遇到这种题目，暴力解法就是双重循环，优化就是双指针或者辅助空间。而题目不允许使用辅助空间，那只能是双指针了，但是这两个只出现一次的数字之间并没有联系啊。

我们可以使用异或这个概念，当两个数字相等时异或的值为0，否则不为零。而除了这两个只出现一次的数字之外，其他数字都出现了两次，那么从头到尾进行异或最终的结果就是这两个数字的异或值了。

然后我们将数组分成两区间，只需要保证每个区间各包含一个只出现一次的数字就可以了。将上面的异或的结果拿到然后找出其中那一位为 1 ，根据这一位将数组分为该位为 1 和 0 的两个区间，这样就保证每边各一个了，然后分别异或，两个区间得出的结果就是这两个数字了。



