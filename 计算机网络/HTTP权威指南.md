## URL

URL 是通过描述资源的位置来标识资源的，而 URL 是 URI 的子集 ，但是她们目前是基本上不区分。

URL 分成三部分：URL 方案 + 服务器的位置 + 资源路径

~~~
https://www.joes-hardware.com/index.html
~~~

完整的 URL ：

~~~url
<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>
~~~



## http 报文

报文的组成部分：

- 起始行
- 首部
  - 在 http2 之前，起始行和首部都是 ASCII 码文本；而主体中可以为二进制、 ASCII 文本或者为空。
  - （一般认为，文本文件编码基于字符定长，译码容易些；二进制文件编码是变长的，所以它灵活，存储利用率要高些，译码难一些）
- 主体（可选）



请求报文示例：

~~~
GET /specials/saw-blade.txt HTTP/1.0
Hosts: www.joes-hardware.com
~~~

响应报文示例：

~~~
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 19

Hi! I'm a message!
~~~



### 常见的请求方法

- get 
- head
  - 相比于 get ，它的响应只返回首部，是的客户端可以在不获取实质性内容的情况下对响应资源的首部进行检验。
- put 
  - 让服务器用请求的主体部分来创建一个由请求的 URL 命名的新文档；或者替换该 URL 上的文档
- post 
  - 向服务器输入数据
- trace
  - trace 方法允许客户端查看最终传给服务器时的请求变成了什么样子
  - trace 方法在该请求传到服务器的时候直接将该请求的全部内容放在响应体里返回
- options 
  - 请求服务器告知其支持的请求方法、请求头或者某个资源的特定请求方式
- delete 
  - 请求服务器删除 URL 对应的资源



### 状态码

302 、 303 、 307 状态码的区别

http/1.0 中，如果客户端发起 post 请求并收到 302 重定向的状态码，会自动向响应的 URL 发起 get 请求而非 post 请求。

http/1.1 中，用 303 实现同样的行为，但是当客户端的POST请求收到服务端307状态码响应时，需要跟用户询问是否应该在新URI上发起POST方法，也就是说，307是不会把POST转为GET的



### 首部

connection 首部及逐跳首部。

connection 首部和一些其他的首部是不能被代理转发或者作为缓存响应使用的，因为他们是面向一条连接（两个相邻的 http 应用）而非客户端与服务器的，否则会造成下面 [keep-alive][] 连接的问题。





## 连接

### Tcp 链接：

time_wait 与端口耗尽的问题：

-  time_wait 避免了在两分钟（2 msl）内重复创建两个相同 IP 地址的连接，避免了上一个连接的未发送到的老报文影响到下一个新链接（因为双方都无法确定关闭连接的瞬间另一方是否正在发送报文）。
- 但是 time_wait 时间过长会造成端口耗尽问题（即在 time_wait 时间内这个端口无法再次使用）（端口号保证了链接的唯一性）



### HTTP 连接

并行链接：

- 只有在单个链接无法完全利用网络带宽时能提高加载速度，如果带宽不足，打开大量链接会消耗更多的网络和内存资源，为了限制对服务器内存资源的占用，一般浏览器对于一个域名下的链接一般只有 4 条左右。≤



持久链接：

- 节省了每个 http 请求和响应都要重新打开一条 tcp 链接浪费的时间，此外还避免了每个 tcp 链接开始时的慢启动机制。

- keep-alive 首部：在 http/1.0 中用作持久链接的首部
  - 请求和响应中都必须包含 keep-alive 首部，不然会认为其中一方不支持而不开启持久链接。
  - ==启用了持久连接的报文必须要准确的标明实体部分长度==，不然会导致无法正确分割两个报文。（否则只能通过一个报文一条新链接的形式分割）
  - 下面的响应首部的例子表示服务器最多会为另外的五个事务保持这个连接、或者在连接空闲了两分钟之后关闭。

~~~
connection: Keep-Alive
Keep-alive: max=5, timeout=120
~~~

- keep-alive 首部与哑代理
  - 首先，connection 首部是一个逐跳首部，不能被转发，因为他只代表两个相邻的 http 应用程序之间共享的一些选项。而哑代理不会识别这个首部，而是直接进行了转发，就会出现问题。
  - 因此如果哑代理选择了直接全部转发，对于服务器来说，他就以为代理（因为代理跟其他客户端没什么区别）希望进行持久链接；而对于客户端来说，根据代理转发的响应报文，他会以为代理同意了持久连接请求。
  - 但是对于哑代理来说，他认为连接都会是短链接，因此会在转发完信息之后一直等待连接的关闭，从而之后的请求都会被忽略，直到超时。
- http/1.1 中默认使用持久连接，除非服务器响应 / 客户端请求中携带了 `Connection: close `首部表示关闭连接，并限制客户端新的请求。（但是客户端和服务器依然可以随时关闭连接）此外：==启用了持久连接的报文必须要准确的标明实体部分长度（Content-Length）==

- 管道化连接：
  - 允许客户端在响应到达前发送更多的请求（请求队列实现）
  - 必须确保连接是持久链接
  - 客户端和服务器必须做好连接时刻被关闭的准备
  - 不应该发送一些不幂等的请求 



## 代理





